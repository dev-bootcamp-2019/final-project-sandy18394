{
  "_args": [
    [
      {
        "raw": "varint@^5.0.0",
        "scope": null,
        "escapedName": "varint",
        "name": "varint",
        "rawSpec": "^5.0.0",
        "spec": ">=5.0.0 <6.0.0",
        "type": "range"
      },
      "/Users/sandeepghosh/Desktop/blockchain/smart contracts/dappRoll2Win/dumed/node_modules/multicodec"
    ]
  ],
  "_from": "varint@>=5.0.0 <6.0.0",
  "_id": "varint@5.0.0",
  "_inCache": true,
  "_location": "/varint",
  "_nodeVersion": "6.9.1",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/varint-5.0.0.tgz_1478286939731_0.956488419091329"
  },
  "_npmUser": {
    "name": "chrisdickinson",
    "email": "chris@neversaw.us"
  },
  "_npmVersion": "3.10.8",
  "_phantomChildren": {},
  "_requested": {
    "raw": "varint@^5.0.0",
    "scope": null,
    "escapedName": "varint",
    "name": "varint",
    "rawSpec": "^5.0.0",
    "spec": ">=5.0.0 <6.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/mafmt/multiaddr",
    "/multiaddr",
    "/multicodec",
    "/multihashes",
    "/peer-info/multiaddr",
    "/protons",
    "/signed-varint"
  ],
  "_resolved": "https://registry.npmjs.org/varint/-/varint-5.0.0.tgz",
  "_shasum": "d826b89f7490732fabc0c0ed693ed475dcb29ebf",
  "_shrinkwrap": null,
  "_spec": "varint@^5.0.0",
  "_where": "/Users/sandeepghosh/Desktop/blockchain/smart contracts/dappRoll2Win/dumed/node_modules/multicodec",
  "author": {
    "name": "Chris Dickinson",
    "email": "chris@neversaw.us"
  },
  "bugs": {
    "url": "https://github.com/chrisdickinson/varint/issues"
  },
  "dependencies": {},
  "description": "protobuf-style varint bytes - use msb to create integer values of varying sizes",
  "devDependencies": {
    "tape": "~2.12.3"
  },
  "directories": {},
  "dist": {
    "shasum": "d826b89f7490732fabc0c0ed693ed475dcb29ebf",
    "tarball": "https://registry.npmjs.org/varint/-/varint-5.0.0.tgz"
  },
  "gitHead": "30e24d424c278a4d4ee33d4a00910fc12af95e2b",
  "homepage": "https://github.com/chrisdickinson/varint#readme",
  "keywords": [
    "varint",
    "protobuf",
    "encode",
    "decode"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "chrisdickinson",
      "email": "chris@neversaw.us"
    }
  ],
  "name": "varint",
  "optionalDependencies": {},
  "readme": "# varint\n\nencode whole numbers to an array of [protobuf-style varint bytes](https://developers.google.com/protocol-buffers/docs/encoding#varints) and also decode them.\n\n```javascript\nvar varint = require('varint')\n\nvar bytes = varint.encode(300) // === [0xAC, 0x02]\nvarint.decode(bytes) // 300\nvarint.decode.bytes // 2 (the last decode() call required 2 bytes)\n```\n\n## api\n\n### varint = require('varint')\n\n### varint.encode(num[, buffer=[], offset=0]) -> buffer\n\nEncodes `num` into `buffer` starting at `offset`. returns `buffer`, with the encoded varint written into it. If `buffer` is not provided, it will default to a new array.\n\n`varint.encode.bytes` will now be set to the number of bytes\nmodified.\n\n### varint.decode(data[, offset=0]) -> number\n\ndecodes `data`, which can be either a buffer or array of integers, from position `offset` or default 0 and returns the decoded original integer.\n\nThrows a `RangeError` when `data` does not represent a valid encoding.\n\n### varint.decode.bytes\n\nif you also require the length (number of bytes) that were required to decode the integer you can access it via `varint.decode.bytes`. this is an integer property that will tell you the number of bytes that the last .decode() call had to use to decode.\n\n### varint.encode.bytes\n\nsimilar to `decode.bytes` when encoding a number it can be useful to know how many bytes where written (especially if you pass an output array). you can access this via `varint.encode.bytes` which holds the number of bytes written in the last encode.\n\n\n### varint.encodingLength(num)\n\nreturns the number of bytes this number will be encoded as, up to a maximum of 8.\n\n## usage notes\n\nIf varint is passed a buffer that does not contain a valid end\nbyte, then `decode` will throw `RangeError`, and `decode.bytes` \nwill be set to 0. If you are reading from a streaming source,\nit's okay to pass an incomplete buffer into `decode`, detect this\ncase, and then concatenate the next buffer.\n\n# License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/chrisdickinson/varint.git"
  },
  "scripts": {
    "test": "node test.js"
  },
  "version": "5.0.0"
}
